"use strict";(()=>{var e={};e.id=4641,e.ids=[4641,660],e.modules={502:(e,t,r)=>{r.r(t),r.d(t,{config:()=>y,default:()=>f,getServerSideProps:()=>b,getStaticPaths:()=>w,getStaticProps:()=>g,reportWebVitals:()=>q,routeModule:()=>k,unstable_getServerProps:()=>P,unstable_getServerSideProps:()=>j,unstable_getStaticParams:()=>_,unstable_getStaticPaths:()=>S,unstable_getStaticProps:()=>v});var s={};r.r(s),r.d(s,{default:()=>m,getStaticProps:()=>h});var a=r(7093),n=r(5244),o=r(1323),i=r(2899),u=r.n(i),l=r(9413),c=r(997),d=r(1475),p=r(1354),x=r(6833);async function h(){let e=await r.e(1317).then(r.t.bind(r,1317,19));return{props:{siteName:e.default.name,google_analytics_tracking_id:e.default.google_analytics_tracking_id,google_adsense_publisher_id:e.default.google_adsense_publisher_id,title:"How would you write an arrow function that takes a single parameter and returns its square?",description:"Test your knowledge of JavaScript's arrow functions (lambda expressions) in this comprehensive quiz. Learn about concise syntax, lexical this binding, implicit returns, and when to use arrow functions versus traditional function expressions."}}}let m=(0,p.Z)((0,x.Z)(()=>(0,c.jsxs)(c.Fragment,{children:[c.jsx("h1",{className:"text-2xl dark:text-white text-center",children:"Arrow Functions"}),c.jsx("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:c.jsx(d.Y3,{activeQuestionIndex:12,totalQuestions:20,index:12,question:"How would you write an arrow function that takes a single parameter and returns its square?",options:["square = x -> x * x;","const square = x => x * x;","const square = (x) => { x * x };","const square = x => return x * x;"],code:void 0,nextQuestionPath:"what-is-the-output-of-this-code",correctAnswer:2,explanation:"The correct way to write an arrow function that takes a single parameter and returns its square is `const square = x => x * x;`. This demonstrates two key features of arrow function syntax: 1) When there's only one parameter, the parentheses around the parameter list are optional; and 2) When the function body consists of a single expression, the curly braces and `return` keyword can be omitted (implicit return). This concise syntax is one of the main advantages of arrow functions for simple operations. Option 1 uses an incorrect arrow symbol (`->`). Option 3 includes curly braces but is missing the required `return` statement when using a block body. Option 4 incorrectly includes the `return` keyword in a concise body without curly braces. The correct function could also be written with parentheses or a block body as: `const square = (x) => x * x;` or `const square = x => { return x * x; }`, but the solution shown is the most concise valid form.",id:213,quizId:9},12)})]}))),f=(0,o.l)(s,"default"),g=(0,o.l)(s,"getStaticProps"),w=(0,o.l)(s,"getStaticPaths"),b=(0,o.l)(s,"getServerSideProps"),y=(0,o.l)(s,"config"),q=(0,o.l)(s,"reportWebVitals"),v=(0,o.l)(s,"unstable_getStaticProps"),S=(0,o.l)(s,"unstable_getStaticPaths"),_=(0,o.l)(s,"unstable_getStaticParams"),P=(0,o.l)(s,"unstable_getServerProps"),j=(0,o.l)(s,"unstable_getServerSideProps"),k=new a.PagesRouteModule({definition:{kind:n.x.PAGES,page:"/quizzes/functions-and-scope/arrow-functions/how-would-you-write-an-arrow-function-that-takes-a-single-parameter-and-returns-its-square",pathname:"/quizzes/functions-and-scope/arrow-functions/how-would-you-write-an-arrow-function-that-takes-a-single-parameter-and-returns-its-square",bundlePath:"",filename:""},components:{App:l.default,Document:u()},userland:s})},6833:(e,t,r)=>{r.d(t,{Z:()=>o});var s=r(997),a=r(6689);let n=({adClient:e="ca-pub-7544108447932228",adSlot:t="6753219060",className:r})=>{let n=(0,a.useRef)(null);(0,a.useRef)(!1);let[o,i]=(0,a.useState)(!1);return((0,a.useEffect)(()=>(i(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,a.useEffect)(()=>{},[o]),o)?s.jsx("ins",{ref:n,className:`adsbygoogle ${r}`,style:{display:"block"},"data-ad-client":e,"data-ad-slot":t}):null};function o(e){return class extends a.Component{constructor(e){super(e)}componentDidMount(){console.log("Wrapped Component")}render(){return s.jsx(s.Fragment,{children:(0,s.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[s.jsx("div",{children:s.jsx(n,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),s.jsx("div",{children:s.jsx(e,{...this.props})}),s.jsx("div",{children:s.jsx(n,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}}}},9003:e=>{e.exports=require("classnames")},2785:e=>{e.exports=require("next/dist/compiled/next-server/pages.runtime.prod.js")},968:e=>{e.exports=require("next/head")},6689:e=>{e.exports=require("react")},6405:e=>{e.exports=require("react-dom")},997:e=>{e.exports=require("react/jsx-runtime")},7147:e=>{e.exports=require("fs")},1017:e=>{e.exports=require("path")},2781:e=>{e.exports=require("stream")},9796:e=>{e.exports=require("zlib")}};var t=require("../../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),s=t.X(0,[2899,8559,5675,1163,7830],()=>r(502));module.exports=s})();