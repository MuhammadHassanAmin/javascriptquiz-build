"use strict";(()=>{var e={};e.id=7844,e.ids=[7844,660],e.modules={1:(e,t,s)=>{s.r(t),s.d(t,{config:()=>S,default:()=>x,getServerSideProps:()=>b,getStaticPaths:()=>v,getStaticProps:()=>g,reportWebVitals:()=>w,routeModule:()=>k,unstable_getServerProps:()=>j,unstable_getServerSideProps:()=>q,unstable_getStaticParams:()=>P,unstable_getStaticPaths:()=>y,unstable_getStaticProps:()=>_});var n={};s.r(n),s.d(n,{default:()=>m,getStaticProps:()=>h});var r=s(7093),a=s(5244),i=s(1323),o=s(2899),c=s.n(o),l=s(9413),u=s(997),d=s(4815),p=s(1354),f=s(6833);async function h(){let e=await s.e(1317).then(s.t.bind(s,1317,19));return{props:{siteName:e.default.name,google_analytics_tracking_id:e.default.google_analytics_tracking_id,google_adsense_publisher_id:e.default.google_adsense_publisher_id,title:"Which of these statements about closures is false?",description:"Test your knowledge of JavaScript function types, hoisting behavior, scope chains, closures and the key differences between function declarations and expressions in this comprehensive quiz. Master these foundational concepts to write cleaner, more efficient JavaScript code."}}}let m=(0,p.Z)((0,f.Z)(()=>(0,u.jsxs)(u.Fragment,{children:[u.jsx("h1",{className:"text-2xl dark:text-white text-center",children:"Function Declarations vs Expressions"}),u.jsx("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:u.jsx(d.Y3,{activeQuestionIndex:15,totalQuestions:20,index:15,question:"Which of these statements about closures is false?",options:["Closures allow functions to access variables from an outer function scope even after the outer function has returned","Every function in JavaScript creates a closure","Closures consume memory because they prevent variables from being garbage collected","Closures only work with function expressions, not function declarations"],code:void 0,nextQuestionPath:"what-will-be-the-output-of-this-code",correctAnswer:4,explanation:"The false statement is that closures only work with function expressions, not function declarations. In fact, closures work with all functions in JavaScript, regardless of whether they are created using function declarations, function expressions, or arrow functions. A closure is formed whenever a function accesses variables from its outer lexical environment. This capability is a fundamental part of how JavaScript functions work, not limited to a specific syntax for creating functions. Both function declarations (`function name() {}`) and function expressions (`const name = function() {}`) can create closures if they reference variables from their outer scopes. The ability to form closures is related to the lexical scoping mechanism in JavaScript, not to the specific syntax used to define the function. This is why closures are such a powerful and ubiquitous pattern in JavaScript programming.",id:196,quizId:8},15)})]}))),x=(0,i.l)(n,"default"),g=(0,i.l)(n,"getStaticProps"),v=(0,i.l)(n,"getStaticPaths"),b=(0,i.l)(n,"getServerSideProps"),S=(0,i.l)(n,"config"),w=(0,i.l)(n,"reportWebVitals"),_=(0,i.l)(n,"unstable_getStaticProps"),y=(0,i.l)(n,"unstable_getStaticPaths"),P=(0,i.l)(n,"unstable_getStaticParams"),j=(0,i.l)(n,"unstable_getServerProps"),q=(0,i.l)(n,"unstable_getServerSideProps"),k=new r.PagesRouteModule({definition:{kind:a.x.PAGES,page:"/quizzes/functions-and-scope/function-declarations-vs-expressions/which-of-these-statements-about-closures-is-false",pathname:"/quizzes/functions-and-scope/function-declarations-vs-expressions/which-of-these-statements-about-closures-is-false",bundlePath:"",filename:""},components:{App:l.default,Document:c()},userland:n})},6833:(e,t,s)=>{s.d(t,{Z:()=>i});var n=s(997),r=s(6689);let a=({adClient:e="ca-pub-7544108447932228",adSlot:t="6753219060",className:s})=>{let a=(0,r.useRef)(null);(0,r.useRef)(!1);let[i,o]=(0,r.useState)(!1);return((0,r.useEffect)(()=>(o(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,r.useEffect)(()=>{},[i]),i)?n.jsx("ins",{ref:a,className:`adsbygoogle ${s}`,style:{display:"block"},"data-ad-client":e,"data-ad-slot":t}):null};function i(e){return class extends r.Component{constructor(e){super(e)}componentDidMount(){console.log("Wrapped Component")}render(){return n.jsx(n.Fragment,{children:(0,n.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[n.jsx("div",{children:n.jsx(a,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),n.jsx("div",{children:n.jsx(e,{...this.props})}),n.jsx("div",{children:n.jsx(a,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}}}},9003:e=>{e.exports=require("classnames")},2785:e=>{e.exports=require("next/dist/compiled/next-server/pages.runtime.prod.js")},968:e=>{e.exports=require("next/head")},6689:e=>{e.exports=require("react")},6405:e=>{e.exports=require("react-dom")},997:e=>{e.exports=require("react/jsx-runtime")},7147:e=>{e.exports=require("fs")},1017:e=>{e.exports=require("path")},2781:e=>{e.exports=require("stream")},9796:e=>{e.exports=require("zlib")}};var t=require("../../../../webpack-runtime.js");t.C(e);var s=e=>t(t.s=e),n=t.X(0,[2899,8559,5675,1163,2603],()=>s(1));module.exports=n})();