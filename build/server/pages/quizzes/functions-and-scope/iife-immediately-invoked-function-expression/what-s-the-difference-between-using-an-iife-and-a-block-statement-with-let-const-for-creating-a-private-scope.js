"use strict";(()=>{var e={};e.id=2496,e.ids=[2496,660],e.modules={7629:(e,t,s)=>{s.r(t),s.d(t,{config:()=>w,default:()=>g,getServerSideProps:()=>v,getStaticPaths:()=>b,getStaticProps:()=>x,reportWebVitals:()=>I,routeModule:()=>P,unstable_getServerProps:()=>y,unstable_getServerSideProps:()=>E,unstable_getStaticParams:()=>_,unstable_getStaticPaths:()=>k,unstable_getStaticProps:()=>S});var n={};s.r(n),s.d(n,{default:()=>m,getStaticProps:()=>f});var a=s(7093),o=s(5244),i=s(1323),r=s(2899),c=s.n(r),l=s(9413),u=s(997),d=s(1475),p=s(1354),h=s(6833);async function f(){let e=await s.e(1317).then(s.t.bind(s,1317,19));return{props:{siteName:e.default.name,google_analytics_tracking_id:e.default.google_analytics_tracking_id,google_adsense_publisher_id:e.default.google_adsense_publisher_id,title:"What's the difference between using an IIFE and a block statement with let/const for creating a private scope?",description:"Challenge yourself with our comprehensive JavaScript IIFE quiz. Test your understanding of Immediately Invoked Function Expressions, self-executing functions, module patterns, and execution context isolation in JavaScript."}}}let m=(0,p.Z)((0,h.Z)(()=>(0,u.jsxs)(u.Fragment,{children:[u.jsx("h1",{className:"text-2xl dark:text-white text-center",children:"IIFE (Immediately Invoked Function Expression)"}),u.jsx("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:u.jsx(d.Y3,{activeQuestionIndex:18,totalQuestions:25,index:18,question:"What's the difference between using an IIFE and a block statement with let/const for creating a private scope?",options:["There is no difference; they both create a private scope","The IIFE creates a function scope while the block creates a block scope, but they function similarly for let/const","The block approach doesn't work; variables will still leak to the outer scope","The IIFE approach is always more efficient"],code:"// Approach 1: IIFE\n(function() {\n  const x = 10;\n  console.log(x);\n})();\n\n// Approach 2: Block with let/const\n{\n  const x = 10;\n  console.log(x);\n}",nextQuestionPath:"what-will-the-following-code-output",correctAnswer:2,explanation:"The main difference is that the IIFE creates a function scope while the block creates a block scope, but they function similarly for let/const. With the introduction of let and const in ES6, which have block scope, a simple block statement can now be used to create a private scope for variables without needing an IIFE. Both approaches effectively prevent the variables inside them from leaking to the outer scope. The block approach is more concise, but the IIFE approach has additional benefits: it can return values, accept parameters, and create closures that persist after the IIFE completes. The IIFE approach was also the only option before ES6. The choice between them depends on your specific needs - use a block for simple scoping, and an IIFE when you need function features like return values or closures.",id:300,quizId:13},18)})]}))),g=(0,i.l)(n,"default"),x=(0,i.l)(n,"getStaticProps"),b=(0,i.l)(n,"getStaticPaths"),v=(0,i.l)(n,"getServerSideProps"),w=(0,i.l)(n,"config"),I=(0,i.l)(n,"reportWebVitals"),S=(0,i.l)(n,"unstable_getStaticProps"),k=(0,i.l)(n,"unstable_getStaticPaths"),_=(0,i.l)(n,"unstable_getStaticParams"),y=(0,i.l)(n,"unstable_getServerProps"),E=(0,i.l)(n,"unstable_getServerSideProps"),P=new a.PagesRouteModule({definition:{kind:o.x.PAGES,page:"/quizzes/functions-and-scope/iife-immediately-invoked-function-expression/what-s-the-difference-between-using-an-iife-and-a-block-statement-with-let-const-for-creating-a-private-scope",pathname:"/quizzes/functions-and-scope/iife-immediately-invoked-function-expression/what-s-the-difference-between-using-an-iife-and-a-block-statement-with-let-const-for-creating-a-private-scope",bundlePath:"",filename:""},components:{App:l.default,Document:c()},userland:n})},6833:(e,t,s)=>{s.d(t,{Z:()=>i});var n=s(997),a=s(6689);let o=({adClient:e="ca-pub-7544108447932228",adSlot:t="6753219060",className:s})=>{let o=(0,a.useRef)(null);(0,a.useRef)(!1);let[i,r]=(0,a.useState)(!1);return((0,a.useEffect)(()=>(r(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,a.useEffect)(()=>{},[i]),i)?n.jsx("ins",{ref:o,className:`adsbygoogle ${s}`,style:{display:"block"},"data-ad-client":e,"data-ad-slot":t}):null};function i(e){return class extends a.Component{constructor(e){super(e)}componentDidMount(){console.log("Wrapped Component")}render(){return n.jsx(n.Fragment,{children:(0,n.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[n.jsx("div",{children:n.jsx(o,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),n.jsx("div",{children:n.jsx(e,{...this.props})}),n.jsx("div",{children:n.jsx(o,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}}}},9003:e=>{e.exports=require("classnames")},2785:e=>{e.exports=require("next/dist/compiled/next-server/pages.runtime.prod.js")},968:e=>{e.exports=require("next/head")},6689:e=>{e.exports=require("react")},6405:e=>{e.exports=require("react-dom")},997:e=>{e.exports=require("react/jsx-runtime")},7147:e=>{e.exports=require("fs")},1017:e=>{e.exports=require("path")},2781:e=>{e.exports=require("stream")},9796:e=>{e.exports=require("zlib")}};var t=require("../../../../webpack-runtime.js");t.C(e);var s=e=>t(t.s=e),n=t.X(0,[2899,8559,5675,1163,7830],()=>s(7629));module.exports=n})();