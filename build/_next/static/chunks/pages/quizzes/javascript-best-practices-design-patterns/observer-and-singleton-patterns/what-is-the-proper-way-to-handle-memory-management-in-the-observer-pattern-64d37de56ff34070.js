(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[66522],{89435:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-best-practices-design-patterns/observer-and-singleton-patterns/what-is-the-proper-way-to-handle-memory-management-in-the-observer-pattern",function(){return t(91430)}])},16833:function(e,n,t){"use strict";t.d(n,{Z:function(){return a}});var r=t(85893),s=t(67294),o=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:t="6753219060",adFormat:o="auto",className:a,fullWidthResponsive:i="true"}=e,c=(0,s.useRef)(null),l=(0,s.useRef)(!1),[d,u]=(0,s.useState)(!1);return((0,s.useEffect)(()=>(u(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,s.useEffect)(()=>{if(d){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))c.current&&!l.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),l.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{c.current&&!l.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),l.current=!0)}}}},[d]),d)?(0,r.jsx)("ins",{ref:c,className:"adsbygoogle ".concat(a),style:{display:"block"},"data-ad-client":n,"data-ad-slot":t,"data-ad-format":o,"data-full-width-responsive":i}):null};function a(e){return class extends s.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,r.jsx)("div",{children:(0,r.jsx)(o,{adSlot:"6753219060",className:"h-[100px] md:h-full top-0 sticky"})}),(0,r.jsx)("div",{children:(0,r.jsx)(e,{...this.props})}),(0,r.jsx)("div",{children:(0,r.jsx)(o,{adSlot:"6208304795",className:"h-[300px] md:h-full top-0 sticky"})})]})})}constructor(e){super(e)}}}},91430:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return i}});var r=t(85893),s=t(1475),o=t(25190),a=t(16833),i=!0;n.default=(0,o.Z)((0,a.Z)(()=>(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Observer & Singleton Patterns"}),(0,r.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,r.jsx)(s.Y3,{activeQuestionIndex:13,totalQuestions:15,index:13,question:"What is the proper way to handle memory management in the Observer Pattern?",options:["Keep all observers indefinitely","Use strong references for all observers","Use WeakSet/WeakMap for observer storage","Manually delete observers"],code:"class WeakSubject {\n  constructor() {\n    this.observers = new WeakSet();\n  }\n\n  subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      throw new Error('Observer must be an object');\n    }\n    this.observers.add(observer);\n  }\n\n  notify(data) {\n    // Convert WeakSet to array for iteration\n    const currentObservers = Array.from(this.observers);\n    currentObservers.forEach(observer => {\n      if (observer.update) {\n        observer.update(data);\n      }\n    });\n  }\n}",nextQuestionPath:"what-are-the-best-practices-for-implementing-a-singleton-in-a-module-system",correctAnswer:3,explanation:"This implementation demonstrates proper memory management using WeakSet by: 1) Allowing garbage collection of observers when they're no longer referenced elsewhere, 2) Preventing memory leaks from forgotten subscriptions, 3) Maintaining weak references to observers, and 4) Ensuring proper cleanup without manual intervention. This approach is particularly important in long-running applications or those with dynamic observer creation/removal.",id:1454,quizId:64},13)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=89435)}),_N_E=e.O()}]);