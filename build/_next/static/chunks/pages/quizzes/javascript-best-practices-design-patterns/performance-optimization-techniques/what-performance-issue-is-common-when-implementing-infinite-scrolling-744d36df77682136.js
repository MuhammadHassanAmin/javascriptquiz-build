(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[95796],{47810:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-best-practices-design-patterns/performance-optimization-techniques/what-performance-issue-is-common-when-implementing-infinite-scrolling",function(){return t(33992)}])},16833:function(e,n,t){"use strict";t.d(n,{Z:function(){return i}});var s=t(85893),r=t(67294),o=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:t="6753219060",className:o}=e,i=(0,r.useRef)(null),a=(0,r.useRef)(!1),[c,l]=(0,r.useState)(!1);return((0,r.useEffect)(()=>(l(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,r.useEffect)(()=>{if(c){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))i.current&&!a.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),a.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{i.current&&!a.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),a.current=!0)}}}},[c]),c)?(0,s.jsx)("ins",{ref:i,className:"adsbygoogle ".concat(o),style:{display:"block"},"data-ad-client":n,"data-ad-slot":t}):null};function i(e){return class extends r.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,s.jsx)(s.Fragment,{children:(0,s.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,s.jsx)("div",{children:(0,s.jsx)(o,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,s.jsx)("div",{children:(0,s.jsx)(e,{...this.props})}),(0,s.jsx)("div",{children:(0,s.jsx)(o,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},33992:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return a}});var s=t(85893),r=t(1475),o=t(41354),i=t(16833),a=!0;n.default=(0,o.Z)((0,i.Z)(()=>(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Performance Optimization Techniques"}),(0,s.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,s.jsx)(r.Y3,{activeQuestionIndex:25,totalQuestions:40,index:25,question:"What performance issue is common when implementing infinite scrolling?",options:["Network latency from too many API requests","DOM size growing unbounded, causing memory and performance problems","Worker thread congestion","WebGL context overflow"],code:void 0,nextQuestionPath:"what-performance-technique-does-this-code-implement",correctAnswer:2,explanation:"The most common performance issue with infinite scrolling implementations is DOM size growing unbounded, causing memory and performance problems. As users scroll and more content is added to the page, the DOM tree continues to grow, leading to several problems: 1) Increased memory usage, 2) Slower DOM operations as browsers must manage larger trees, 3) Degraded scrolling performance and responsiveness, and 4) Potential browser crashes with very large DOMs. To address this issue, implement a virtualized or windowed list approach: only render elements that are visible or near the viewport, and remove (or recycle) elements that are far outside the viewport. Libraries like react-window, react-virtualized, vue-virtual-scroller, or techniques like the Intersection Observer API can help implement efficient infinite scrolling that maintains good performance regardless of the total number of items.",id:1521,quizId:67},25)})]})))}},function(e){e.O(0,[41966,25675,61793,92888,49774,40179],function(){return e(e.s=47810)}),_N_E=e.O()}]);