(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[47285],{51349:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-best-practices-design-patterns/performance-optimization-techniques/when-working-with-large-arrays-in-performance-critical-code-which-approach-is-generally-more-efficient",function(){return n(51249)}])},16833:function(e,t,n){"use strict";n.d(t,{Z:function(){return o}});var r=n(85893),i=n(67294),a=e=>{let{adClient:t="ca-pub-7544108447932228",adSlot:n="6753219060",className:a}=e,o=(0,i.useRef)(null),s=(0,i.useRef)(!1),[c,l]=(0,i.useState)(!1);return((0,i.useEffect)(()=>(l(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,i.useEffect)(()=>{if(c){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))o.current&&!s.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),s.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{o.current&&!s.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),s.current=!0)}}}},[c]),c)?(0,r.jsx)("ins",{ref:o,className:"adsbygoogle ".concat(a),style:{display:"block"},"data-ad-client":t,"data-ad-slot":n}):null};function o(e){return class extends i.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,r.jsx)("div",{children:(0,r.jsx)(a,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,r.jsx)("div",{children:(0,r.jsx)(e,{...this.props})}),(0,r.jsx)("div",{children:(0,r.jsx)(a,{adSlot:"6208304795",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},51249:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return s}});var r=n(85893),i=n(1475),a=n(25190),o=n(16833),s=!0;t.default=(0,a.Z)((0,o.Z)(()=>(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Performance Optimization Techniques"}),(0,r.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,r.jsx)(i.Y3,{activeQuestionIndex:29,totalQuestions:40,index:29,question:"When working with large arrays in performance-critical code, which approach is generally more efficient?",options:["Using Array.prototype methods like map(), filter(), and reduce()","Using for...of loops","Using traditional for loops with cached length","Using Array.prototype.forEach()"],code:void 0,nextQuestionPath:"what-performance-benefit-does-using-the-will-change-css-property-provide",correctAnswer:3,explanation:"Using traditional for loops with cached length is generally the most efficient approach when working with large arrays in performance-critical code. This approach has several advantages: 1) It minimizes overhead by avoiding function calls for each iteration, 2) Caching the array length (const len = array.length) prevents re-checking the length property on each iteration, 3) It gives you full control over the iteration process, and 4) Modern JavaScript engines are highly optimized for this pattern. While Array methods like map() and filter() provide better readability and are suitable for most cases, they create additional function contexts and often generate intermediate arrays. The performance difference becomes more noticeable with very large arrays (thousands or millions of elements) or when the operation runs frequently in performance-critical paths.",id:1525,quizId:67},29)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=51349)}),_N_E=e.O()}]);