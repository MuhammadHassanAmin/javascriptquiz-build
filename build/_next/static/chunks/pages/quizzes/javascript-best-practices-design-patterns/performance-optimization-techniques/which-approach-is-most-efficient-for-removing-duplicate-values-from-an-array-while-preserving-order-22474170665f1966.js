(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[63596],{56985:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-best-practices-design-patterns/performance-optimization-techniques/which-approach-is-most-efficient-for-removing-duplicate-values-from-an-array-while-preserving-order",function(){return t(40393)}])},16833:function(e,n,t){"use strict";t.d(n,{Z:function(){return s}});var r=t(85893),a=t(67294),i=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:t="6753219060",adFormat:i="auto",className:s,fullWidthResponsive:o="true",style:c={}}=e,l=(0,a.useRef)(null),d=(0,a.useRef)(!1),[u,p]=(0,a.useState)(!1);return((0,a.useEffect)(()=>(p(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,a.useEffect)(()=>{if(u){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))l.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{l.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0)}}}},[u]),u)?(0,r.jsx)("ins",{ref:l,className:"adsbygoogle ".concat(s),style:{display:"block",...c},"data-ad-client":n,"data-ad-slot":t,"data-ad-format":i,"data-full-width-responsive":o}):null};function s(e){return class extends a.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,r.jsx)("div",{children:(0,r.jsx)(i,{adSlot:"6753219060",className:"h-[100px] md:h-full top-0 sticky"})}),(0,r.jsx)("div",{children:(0,r.jsx)(e,{...this.props})}),(0,r.jsx)("div",{children:(0,r.jsx)(i,{adSlot:"6208304795",className:"h-[336px] top-0 sticky",style:{display:"inline-block",height:"280px"}})})]})})}constructor(e){super(e)}}}},40393:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return o}});var r=t(85893),a=t(1475),i=t(25190),s=t(16833),o=!0;n.default=(0,i.Z)((0,s.Z)(()=>(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Performance Optimization Techniques"}),(0,r.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,r.jsx)(a.Y3,{activeQuestionIndex:24,totalQuestions:40,index:24,question:"Which approach is most efficient for removing duplicate values from an array while preserving order?",options:["Using multiple nested loops to compare values","Using Array.prototype.filter() with indexOf() check","Converting to Set and back to Array","Using a Map to track seen values"],code:void 0,nextQuestionPath:"what-performance-issue-is-common-when-implementing-infinite-scrolling",correctAnswer:3,explanation:"Converting to a Set and back to an Array is generally the most efficient approach for removing duplicate values from an array while preserving order. This can be done in one line of code: const uniqueArray = [...new Set(originalArray)]. This approach has O(n) time complexity as it only requires a single pass through the array. The Set data structure automatically handles uniqueness checks with O(1) operations, and spreading it back into an array preserves the original order of first appearance. In contrast, nested loops have O(n\xb2) complexity, while filter() with indexOf() is also O(n\xb2) since indexOf() performs a linear search for each element. Using a Map to track seen values is also O(n) but requires more code. For very large arrays or performance-critical code, benchmark different approaches in your specific environment.",id:1520,quizId:67},24)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=56985)}),_N_E=e.O()}]);