(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[63746],{67485:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-in-the-browser/intersection-observer-and-efficient-scroll-handling/how-can-you-optimize-performance-when-observing-many-elements-simultaneously",function(){return t(69510)}])},16833:function(e,n,t){"use strict";t.d(n,{Z:function(){return a}});var s=t(85893),r=t(67294),o=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:t="6753219060",className:o}=e,a=(0,r.useRef)(null),i=(0,r.useRef)(!1),[l,c]=(0,r.useState)(!1);return((0,r.useEffect)(()=>(c(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,r.useEffect)(()=>{if(l){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))a.current&&!i.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),i.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{a.current&&!i.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),i.current=!0)}}}},[l]),l)?(0,s.jsx)("ins",{ref:a,className:"adsbygoogle ".concat(o),style:{display:"block"},"data-ad-client":n,"data-ad-slot":t}):null};function a(e){return class extends r.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,s.jsx)(s.Fragment,{children:(0,s.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,s.jsx)("div",{children:(0,s.jsx)(o,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,s.jsx)("div",{children:(0,s.jsx)(e,{...this.props})}),(0,s.jsx)("div",{children:(0,s.jsx)(o,{adSlot:"6208304795",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},69510:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return i}});var s=t(85893),r=t(1475),o=t(25190),a=t(16833),i=!0;n.default=(0,o.Z)((0,a.Z)(()=>(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Intersection Observer & Efficient Scroll Handling"}),(0,s.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,s.jsx)(r.Y3,{activeQuestionIndex:7,totalQuestions:20,index:7,question:"How can you optimize performance when observing many elements simultaneously?",options:["Create multiple observers","Use lower threshold values","Unobserve elements after handling them","Increase rootMargin"],code:"const observer = new IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      observer.unobserve(entry.target);\n      loadImage(entry.target);\n    }\n  });\n});\n\ndocument.querySelectorAll('img[data-src]').forEach(img => {\n  observer.observe(img);\n});",nextQuestionPath:"how-should-you-handle-scroll-based-infinite-loading-to-prevent-performance-issues",correctAnswer:3,explanation:"When observing many elements, it's important to unobserve elements after their intersection has been handled to optimize performance. This approach: 1) Reduces the number of elements being actively observed, 2) Prevents unnecessary callback executions for elements that have already been processed, 3) Frees up browser resources, 4) Is particularly important for lazy loading implementations where you don't need to keep tracking elements after they're loaded. The example code demonstrates this pattern with image lazy loading, where each image is unobserved after its src is set.",id:1680,quizId:75},7)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=67485)}),_N_E=e.O()}]);