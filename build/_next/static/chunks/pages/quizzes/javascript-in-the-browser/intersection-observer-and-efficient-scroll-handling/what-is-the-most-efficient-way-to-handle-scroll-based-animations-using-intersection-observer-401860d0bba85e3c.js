(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[60719],{37136:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-in-the-browser/intersection-observer-and-efficient-scroll-handling/what-is-the-most-efficient-way-to-handle-scroll-based-animations-using-intersection-observer",function(){return n(28408)}])},16833:function(e,t,n){"use strict";n.d(t,{Z:function(){return r}});var s=n(85893),o=n(67294),i=e=>{let{adClient:t="ca-pub-7544108447932228",adSlot:n="6753219060",adFormat:i="auto",className:r,fullWidthResponsive:a="true"}=e,l=(0,o.useRef)(null),c=(0,o.useRef)(!1),[d,u]=(0,o.useState)(!1);return((0,o.useEffect)(()=>(u(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,o.useEffect)(()=>{if(d){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))l.current&&!c.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),c.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{l.current&&!c.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),c.current=!0)}}}},[d]),d)?(0,s.jsx)("ins",{ref:l,className:"adsbygoogle ".concat(r),style:{display:"block"},"data-ad-client":t,"data-ad-slot":n,"data-ad-format":i,"data-full-width-responsive":a}):null};function r(e){return class extends o.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,s.jsx)(s.Fragment,{children:(0,s.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,s.jsx)("div",{children:(0,s.jsx)(i,{adSlot:"6753219060",className:"h-[100px] md:h-full top-0 sticky"})}),(0,s.jsx)("div",{children:(0,s.jsx)(e,{...this.props})}),(0,s.jsx)("div",{children:(0,s.jsx)(i,{adSlot:"6208304795",className:"h-[300px] md:h-full top-0 sticky"})})]})})}constructor(e){super(e)}}}},28408:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return a}});var s=n(85893),o=n(1475),i=n(25190),r=n(16833),a=!0;t.default=(0,i.Z)((0,r.Z)(()=>(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Intersection Observer & Efficient Scroll Handling"}),(0,s.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,s.jsx)(o.Y3,{activeQuestionIndex:5,totalQuestions:20,index:5,question:"What is the most efficient way to handle scroll-based animations using Intersection Observer?",options:["Use setInterval for smooth animations","Combine with requestAnimationFrame","Use multiple thresholds for granular updates","Add scroll event listeners"],code:"const observer = new IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      entry.target.style.opacity = entry.intersectionRatio;\n      entry.target.style.transform = `translateY(${(1 - entry.intersectionRatio) * 50}px)`;\n    }\n  });\n}, {\n  threshold: Array.from({ length: 100 }, (_, i) => i / 100)\n});",nextQuestionPath:"what-is-the-purpose-of-the-isintersecting-property-in-the-intersectionobserverentry",correctAnswer:3,explanation:"Using multiple thresholds with Intersection Observer is the most efficient way to handle scroll-based animations because: 1) It provides granular control over animation steps without the overhead of scroll events, 2) The browser optimizes intersection calculations internally, 3) Animations can be tied directly to the intersection ratio for smooth transitions, 4) No manual calculations of scroll position or element visibility are needed. The example code creates 100 thresholds for very smooth animations while maintaining performance.",id:1678,quizId:75},5)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=37136)}),_N_E=e.O()}]);