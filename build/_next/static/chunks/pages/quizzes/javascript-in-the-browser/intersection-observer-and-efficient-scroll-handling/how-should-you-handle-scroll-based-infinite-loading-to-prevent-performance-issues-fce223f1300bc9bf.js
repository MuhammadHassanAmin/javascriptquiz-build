(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[16728],{83214:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-in-the-browser/intersection-observer-and-efficient-scroll-handling/how-should-you-handle-scroll-based-infinite-loading-to-prevent-performance-issues",function(){return t(59370)}])},16833:function(e,n,t){"use strict";t.d(n,{Z:function(){return i}});var s=t(85893),o=t(67294),r=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:t="6753219060",className:r}=e,i=(0,o.useRef)(null),a=(0,o.useRef)(!1),[l,c]=(0,o.useState)(!1);return((0,o.useEffect)(()=>(c(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,o.useEffect)(()=>{if(l){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))i.current&&!a.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),a.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{i.current&&!a.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),a.current=!0)}}}},[l]),l)?(0,s.jsx)("ins",{ref:i,className:"adsbygoogle ".concat(r),style:{display:"block"},"data-ad-client":n,"data-ad-slot":t}):null};function i(e){return class extends o.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,s.jsx)(s.Fragment,{children:(0,s.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,s.jsx)("div",{children:(0,s.jsx)(r,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,s.jsx)("div",{children:(0,s.jsx)(e,{...this.props})}),(0,s.jsx)("div",{children:(0,s.jsx)(r,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},59370:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return a}});var s=t(85893),o=t(1475),r=t(41354),i=t(16833),a=!0;n.default=(0,r.Z)((0,i.Z)(()=>(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Intersection Observer & Efficient Scroll Handling"}),(0,s.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,s.jsx)(o.Y3,{activeQuestionIndex:8,totalQuestions:20,index:8,question:"How should you handle scroll-based infinite loading to prevent performance issues?",options:["Use multiple scroll event listeners","Load all content at once","Implement debouncing with setTimeout","Use a loading flag and rootMargin"],code:"const loadMoreCallback = (entries) => {\n  const trigger = entries[0];\n  if (trigger.isIntersecting && !isLoading) {\n    isLoading = true;\n    loadNextPage()\n      .then(() => {\n        isLoading = false;\n      })\n      .catch(error => {\n        console.error('Loading failed:', error);\n        isLoading = false;\n      });\n  }\n};\n\nconst observer = new IntersectionObserver(loadMoreCallback, {\n  root: null,\n  rootMargin: '200px'\n});",nextQuestionPath:"what-is-the-significance-of-the-time-property-in-intersectionobserverentry",correctAnswer:4,explanation:"Efficient infinite loading implementation requires several optimizations: 1) Using a loading flag to prevent multiple simultaneous requests, 2) Setting an appropriate rootMargin to preload content before it's needed, 3) Properly handling loading states and errors, 4) Using Intersection Observer instead of scroll events. The code demonstrates these best practices by maintaining an isLoading flag, using rootMargin for preloading, and ensuring proper error handling. This approach provides a smooth user experience while preventing performance issues like request flooding or unnecessary API calls.",id:1681,quizId:75},8)})]})))}},function(e){e.O(0,[41966,25675,61793,92888,49774,40179],function(){return e(e.s=83214)}),_N_E=e.O()}]);