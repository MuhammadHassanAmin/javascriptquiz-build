(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[16472],{34352:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-in-the-browser/lazy-loading-code-splitting/what-pattern-should-be-used-for-error-boundaries-with-lazy-loaded-react-components",function(){return r(85790)}])},16833:function(e,n,r){"use strict";r.d(n,{Z:function(){return s}});var t=r(85893),o=r(67294),a=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:r="6753219060",className:a}=e,s=(0,o.useRef)(null),d=(0,o.useRef)(!1),[l,i]=(0,o.useState)(!1);return((0,o.useEffect)(()=>(i(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,o.useEffect)(()=>{if(l){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))s.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{s.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0)}}}},[l]),l)?(0,t.jsx)("ins",{ref:s,className:"adsbygoogle ".concat(a),style:{display:"block"},"data-ad-client":n,"data-ad-slot":r}):null};function s(e){return class extends o.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,t.jsx)(t.Fragment,{children:(0,t.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,t.jsx)("div",{children:(0,t.jsx)(a,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,t.jsx)("div",{children:(0,t.jsx)(e,{...this.props})}),(0,t.jsx)("div",{children:(0,t.jsx)(a,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},85790:function(e,n,r){"use strict";r.r(n),r.d(n,{__N_SSG:function(){return d}});var t=r(85893),o=r(1475),a=r(41354),s=r(16833),d=!0;n.default=(0,a.Z)((0,s.Z)(()=>(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Lazy Loading & Code Splitting"}),(0,t.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,t.jsx)(o.Y3,{activeQuestionIndex:12,totalQuestions:20,index:12,question:"What pattern should be used for error boundaries with lazy-loaded React components?",options:["Try/catch blocks only","Global error handler","Error Boundary component wrapping Suspense","No error handling needed"],code:"class ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <FallbackComponent />;\n    }\n    return this.props.children;\n  }\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<Loading />}>\n        <LazyComponent />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}",nextQuestionPath:"what-performance-metric-should-you-monitor-when-implementing-lazy-loading",correctAnswer:3,explanation:"Using Error Boundary components to wrap Suspense and lazy-loaded components is the recommended pattern because: 1) It provides a declarative way to handle loading errors, 2) Prevents errors in lazy-loaded components from crashing the entire application, 3) Allows for graceful fallback UI when loading fails, 4) Integrates well with React's component lifecycle and error handling model. The example shows proper implementation with a fallback UI and clear separation of concerns between error handling, loading states, and component rendering.",id:1568,quizId:69},12)})]})))}},function(e){e.O(0,[41966,25675,61793,92888,49774,40179],function(){return e(e.s=34352)}),_N_E=e.O()}]);