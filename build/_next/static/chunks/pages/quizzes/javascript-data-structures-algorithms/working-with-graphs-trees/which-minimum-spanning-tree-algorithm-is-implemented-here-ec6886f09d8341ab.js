(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[32377],{21468:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/javascript-data-structures-algorithms/working-with-graphs-trees/which-minimum-spanning-tree-algorithm-is-implemented-here",function(){return n(69804)}])},16833:function(e,t,n){"use strict";n.d(t,{Z:function(){return r}});var i=n(85893),s=n(67294),o=e=>{let{adClient:t="ca-pub-7544108447932228",adSlot:n="6753219060",className:o}=e,r=(0,s.useRef)(null),a=(0,s.useRef)(!1),[d,l]=(0,s.useState)(!1);return((0,s.useEffect)(()=>(l(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,s.useEffect)(()=>{if(d){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))r.current&&!a.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),a.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{r.current&&!a.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),a.current=!0)}}}},[d]),d)?(0,i.jsx)("ins",{ref:r,className:"adsbygoogle ".concat(o),style:{display:"block"},"data-ad-client":t,"data-ad-slot":n}):null};function r(e){return class extends s.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,i.jsx)(i.Fragment,{children:(0,i.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,i.jsx)("div",{children:(0,i.jsx)(o,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,i.jsx)("div",{children:(0,i.jsx)(e,{...this.props})}),(0,i.jsx)("div",{children:(0,i.jsx)(o,{adSlot:"6208304795",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},69804:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return a}});var i=n(85893),s=n(1475),o=n(25190),r=n(16833),a=!0;t.default=(0,o.Z)((0,r.Z)(()=>(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Working with Graphs & Trees"}),(0,i.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,i.jsx)(s.Y3,{activeQuestionIndex:18,totalQuestions:21,index:18,question:"Which minimum spanning tree algorithm is implemented here?",options:["Prim's Algorithm","Boruvka's Algorithm","Kruskal's Algorithm","Reverse-Delete Algorithm"],code:"function minSpanningTree(graph) {\n  const edges = [];\n  for (let vertex in graph) {\n    for (let neighbor in graph[vertex]) {\n      edges.push({\n        from: vertex,\n        to: neighbor,\n        weight: graph[vertex][neighbor]\n      });\n    }\n  }\n  \n  edges.sort((a, b) => a.weight - b.weight);\n  const disjointSet = new DisjointSet();\n  const mst = [];\n  \n  // Initialize disjointSet with all vertices\n  for (let vertex in graph) {\n    disjointSet.makeSet(vertex);\n  }\n  \n  for (let edge of edges) {\n    if (disjointSet.find(edge.from) !== disjointSet.find(edge.to)) {\n      mst.push(edge);\n      disjointSet.union(edge.from, edge.to);\n    }\n  }\n  \n  return mst;\n}",nextQuestionPath:"what-operation-in-b-tree-maintenance-is-being-implemented",correctAnswer:3,explanation:"This implements Kruskal's Algorithm because: 1) Sorts all edges by weight initially, 2) Uses Union-Find data structure to detect cycles, 3) Processes edges in order of increasing weight, 4) Builds MST by adding edges that don't create cycles, 5) Maintains forest of trees until complete, 6) O(E log E) time complexity due to sorting, 7) Efficient for sparse graphs, 8) Common choice for MST implementation.",id:1378,quizId:60},18)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=21468)}),_N_E=e.O()}]);