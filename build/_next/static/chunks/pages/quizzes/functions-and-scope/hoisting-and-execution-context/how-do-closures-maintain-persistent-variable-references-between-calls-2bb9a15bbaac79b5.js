(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[61031],{17332:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/functions-and-scope/hoisting-and-execution-context/how-do-closures-maintain-persistent-variable-references-between-calls",function(){return t(82873)}])},16833:function(e,n,t){"use strict";t.d(n,{Z:function(){return o}});var s=t(85893),a=t(67294),i=e=>{let{adClient:n="ca-pub-7544108447932228",adSlot:t="6753219060",adFormat:i="auto",className:o,fullWidthResponsive:r="true",style:c={}}=e,l=(0,a.useRef)(null),u=(0,a.useRef)(!1),[d,h]=(0,a.useState)(!1);return((0,a.useEffect)(()=>(h(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,a.useEffect)(()=>{if(d){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))l.current&&!u.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),u.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{l.current&&!u.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),u.current=!0)}}}},[d]),d)?(0,s.jsx)("ins",{ref:l,className:"adsbygoogle ".concat(o),style:{display:"block",...c},"data-ad-client":n,"data-ad-slot":t,"data-ad-format":i,"data-full-width-responsive":r}):null};function o(e){return class extends a.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,s.jsx)(s.Fragment,{children:(0,s.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,s.jsx)("div",{children:(0,s.jsx)(i,{adSlot:"6753219060",className:"h-[100px] md:h-full top-0 sticky"})}),(0,s.jsx)("div",{children:(0,s.jsx)(e,{...this.props})}),(0,s.jsx)("div",{children:(0,s.jsx)(i,{adSlot:"6208304795",className:"h-[100px] md:h-full top-0 sticky"})})]})})}constructor(e){super(e)}}}},82873:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return r}});var s=t(85893),a=t(1475),i=t(25190),o=t(16833),r=!0;n.default=(0,i.Z)((0,o.Z)(()=>(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Hoisting and Execution Context"}),(0,s.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,s.jsx)(a.Y3,{activeQuestionIndex:16,totalQuestions:20,index:16,question:"How do closures maintain persistent variable references between calls?",options:["15, 15","15, 16","Error: x is not defined","undefined, undefined"],code:"function outer() {\n  var x = 10;\n  function inner() {\n    var y = 5;\n    console.log(x + y);\n    x = x + 1;\n  }\n  return inner;\n}\n\nvar closureFn = outer();\nclosureFn(); // First call\nclosureFn(); // Second call",nextQuestionPath:"what-happens-to-variables-declared-without-var-let-or-const",correctAnswer:2,explanation:"The output will be `15, 16`. This code demonstrates how closures maintain references to variables in their outer lexical environment, not just copies of their values. Here's what happens:\n\n1. The `outer()` function is called and creates a local variable `x` with value 10.\n2. It defines an inner function that accesses both its own local variable `y` and the outer variable `x`.\n3. The inner function is returned and assigned to `closureFn`.\n4. Even though `outer()` has finished executing, the `inner()` function maintains access to the environment where it was created, including the variable `x`.\n5. When `closureFn()` is called the first time, it accesses `x` (which is 10) and `y` (which is 5), logs their sum (15), and increments `x` to 11.\n6. When `closureFn()` is called the second time, it creates a new `y` with value 5, but accesses the same `x` which is now 11, logs their sum (16), and increments `x` to 12.\n\nThis demonstrates that the closure maintains a reference to the variable `x` itself, not just its value at the time of closure creation. Changes to `x` persist between function calls because it's the same variable being accessed each time. This behavior is fundamental to understanding how closures work in JavaScript and enables patterns like data encapsulation and stateful functions.",id:258,quizId:11},16)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=17332)}),_N_E=e.O()}]);