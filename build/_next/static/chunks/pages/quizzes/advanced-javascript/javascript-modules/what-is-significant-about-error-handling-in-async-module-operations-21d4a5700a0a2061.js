(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[61736],{21313:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/advanced-javascript/javascript-modules/what-is-significant-about-error-handling-in-async-module-operations",function(){return n(88898)}])},16833:function(e,t,n){"use strict";n.d(t,{Z:function(){return s}});var o=n(85893),a=n(67294),r=e=>{let{adClient:t="ca-pub-7544108447932228",adSlot:n="6753219060",adFormat:r="auto",className:s,fullWidthResponsive:i="true",style:c={}}=e,l=(0,a.useRef)(null),d=(0,a.useRef)(!1),[u,p]=(0,a.useState)(!1);return((0,a.useEffect)(()=>(p(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,a.useEffect)(()=>{if(u){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))l.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{l.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0)}}}},[u]),u)?(0,o.jsx)("ins",{ref:l,className:"adsbygoogle ".concat(s),style:{display:"block",...c},"data-ad-client":t,"data-ad-slot":n,"data-ad-format":r,"data-full-width-responsive":i}):null};function s(e){return class extends a.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,o.jsx)(o.Fragment,{children:(0,o.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,o.jsx)("div",{children:(0,o.jsx)(r,{adSlot:"6753219060",className:"h-[100px] md:h-full top-0 sticky"})}),(0,o.jsx)("div",{children:(0,o.jsx)(e,{...this.props})}),(0,o.jsx)("div",{children:(0,o.jsx)(r,{adSlot:"6208304795",className:"h-[336px] top-0 sticky",style:{display:"inline-block",height:"280px"}})})]})})}constructor(e){super(e)}}}},88898:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return i}});var o=n(85893),a=n(1475),r=n(25190),s=n(16833),i=!0;t.default=(0,r.Z)((0,s.Z)(()=>(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"JavaScript Modules (import/export)"}),(0,o.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,o.jsx)(a.Y3,{activeQuestionIndex:16,totalQuestions:21,index:16,question:"What is significant about error handling in async module operations?",options:["Errors are automatically handled","Errors can't propagate across module boundaries","Errors must be handled in the same module","Errors propagate normally through Promise chains"],code:"// api.js\nexport async function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  return response.json();\n}\n\n// main.js\nimport { fetchData } from './api.js';\n\ntry {\n  const data = await fetchData();\n} catch (error) {\n  console.error('Failed to fetch:', error);\n}",nextQuestionPath:"what-is-the-purpose-of-module-initialization-order-in-es-modules",correctAnswer:4,explanation:"Error handling in async module operations follows normal Promise error propagation: 1) Errors in async operations propagate through Promise chains across module boundaries, 2) try/catch blocks in async functions can catch errors from imported async functions, 3) Error stacks preserve the cross-module call chain for debugging, 4) Module boundaries don't affect the normal async/await error handling patterns, 5) This allows for centralized error handling at appropriate levels of the application, 6) It works consistently with both statically and dynamically imported modules, 7) This behavior enables proper error handling strategies in modular applications.",id:873,quizId:39},16)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=21313)}),_N_E=e.O()}]);