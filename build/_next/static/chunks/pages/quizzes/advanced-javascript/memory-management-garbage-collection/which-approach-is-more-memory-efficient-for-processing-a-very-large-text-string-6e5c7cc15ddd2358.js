(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[82938],{98338:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/advanced-javascript/memory-management-garbage-collection/which-approach-is-more-memory-efficient-for-processing-a-very-large-text-string",function(){return n(28064)}])},16833:function(e,t,n){"use strict";n.d(t,{Z:function(){return a}});var r=n(85893),s=n(67294),o=e=>{let{adClient:t="ca-pub-7544108447932228",adSlot:n="6753219060",className:o}=e,a=(0,s.useRef)(null),c=(0,s.useRef)(!1),[i,l]=(0,s.useState)(!1);return((0,s.useEffect)(()=>(l(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,s.useEffect)(()=>{if(i){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))a.current&&!c.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),c.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{a.current&&!c.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),c.current=!0)}}}},[i]),i)?(0,r.jsx)("ins",{ref:a,className:"adsbygoogle ".concat(o),style:{display:"block"},"data-ad-client":t,"data-ad-slot":n}):null};function a(e){return class extends s.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,r.jsx)(r.Fragment,{children:(0,r.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,r.jsx)("div",{children:(0,r.jsx)(o,{adSlot:"6753219060",className:"h-[100px] md:h-full"})}),(0,r.jsx)("div",{children:(0,r.jsx)(e,{...this.props})}),(0,r.jsx)("div",{children:(0,r.jsx)(o,{adSlot:"2871546317",className:"h-[300px] md:h-full"})})]})})}constructor(e){super(e)}}}},28064:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return c}});var r=n(85893),s=n(1475),o=n(25190),a=n(16833),c=!0;t.default=(0,o.Z)((0,a.Z)(()=>(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Memory Management & Garbage Collection"}),(0,r.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,r.jsx)(s.Y3,{activeQuestionIndex:37,totalQuestions:40,index:37,question:"Which approach is more memory-efficient for processing a very large text string?",options:["Approach 1, because it creates fewer variables","Approach 2, because it avoids creating many substring objects","Both approaches use the same amount of memory","Memory usage depends on the text content, not the approach"],code:"// Approach 1: Creating substrings\nfunction processLargeText(text) {\n  for (let i = 0; i < text.length; i++) {\n    const substr = text.substring(i, i + 10);\n    // Process substr...\n  }\n}\n\n// Approach 2: Character-by-character access\nfunction processLargeText2(text) {\n  for (let i = 0; i < text.length; i++) {\n    // Process 10 characters without creating substrings\n    for (let j = 0; j < 10 && i + j < text.length; j++) {\n      const char = text[i + j];\n      // Process char...\n    }\n  }\n}",nextQuestionPath:"what-happens-to-memory-usage-when-you-delete-a-property-from-a-javascript-object",correctAnswer:2,explanation:"Approach 2 is more memory-efficient because it avoids substring creation: 1) Approach 1 creates a new string object for each substring, potentially millions for large texts, 2) These temporary strings require memory allocation and eventual garbage collection, 3) Approach 2 accesses characters directly without creating intermediate string objects, 4) This significantly reduces memory pressure and garbage collection overhead, 5) The difference becomes more pronounced as text size increases, 6) Modern JavaScript engines may optimize some string operations, but character-by-character access is still generally more efficient for large-scale processing, 7) This technique is particularly valuable when processing files or network responses incrementally, 8) It demonstrates the general principle of avoiding unnecessary object creation in performance-critical code.",id:978,quizId:42},37)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=98338)}),_N_E=e.O()}]);