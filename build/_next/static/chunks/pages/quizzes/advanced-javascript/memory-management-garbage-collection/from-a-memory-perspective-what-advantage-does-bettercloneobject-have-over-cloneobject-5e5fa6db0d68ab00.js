(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9518],{8072:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/quizzes/advanced-javascript/memory-management-garbage-collection/from-a-memory-perspective-what-advantage-does-bettercloneobject-have-over-cloneobject",function(){return n(58978)}])},16833:function(e,t,n){"use strict";n.d(t,{Z:function(){return a}});var o=n(85893),r=n(67294),s=e=>{let{adClient:t="ca-pub-7544108447932228",adSlot:n="6753219060",adFormat:s="auto",className:a,fullWidthResponsive:c="true",style:i={}}=e,l=(0,r.useRef)(null),d=(0,r.useRef)(!1),[u,p]=(0,r.useState)(!1);return((0,r.useEffect)(()=>(p(!0),()=>{let e=document.getElementById("__next");e&&e.removeAttribute("style")}),[]),(0,r.useEffect)(()=>{if(u){if(document.querySelector('script[src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"]'))l.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0);else{let e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228",e.async=!0,e.crossOrigin="anonymous",document.body.appendChild(e),e.onload=()=>{l.current&&!d.current&&((window.adsbygoogle=window.adsbygoogle||[]).push({}),d.current=!0)}}}},[u]),u)?(0,o.jsx)("ins",{ref:l,className:"adsbygoogle ".concat(a),style:{display:"block",...i},"data-ad-client":t,"data-ad-slot":n,"data-ad-format":s,"data-full-width-responsive":c}):null};function a(e){return class extends r.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,o.jsx)(o.Fragment,{children:(0,o.jsxs)("div",{className:" md:grid grid-cols-[20%_60%_20%]  w-[95%] ",children:[(0,o.jsx)("div",{children:(0,o.jsx)(s,{adSlot:"6753219060",className:"h-[100px] md:h-full top-0 sticky"})}),(0,o.jsx)("div",{children:(0,o.jsx)(e,{...this.props})}),(0,o.jsxs)("div",{children:[(0,o.jsx)("div",{className:"max-h-[336] top-0 sticky",children:(0,o.jsx)(s,{adSlot:"6208304795",className:"h-[336px]",style:{display:"block",width:"100%",height:"336px"}})}),(0,o.jsx)("div",{className:"max-h-[336] top-0 sticky",children:(0,o.jsx)(s,{adSlot:"6208304795",className:"h-[336px]",style:{display:"block",width:"100%",height:"336px"}})})]})]})})}constructor(e){super(e)}}}},58978:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return c}});var o=n(85893),r=n(1475),s=n(25190),a=n(16833),c=!0;t.default=(0,s.Z)((0,a.Z)(()=>(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)("h1",{className:"text-2xl dark:text-white text-center",children:"Memory Management & Garbage Collection"}),(0,o.jsx)("div",{className:"flex justify-center w-full p-5 md:p-0 pt-0",children:(0,o.jsx)(r.Y3,{activeQuestionIndex:33,totalQuestions:40,index:33,question:"From a memory perspective, what advantage does betterCloneObject have over cloneObject?",options:["It uses less memory overall","It works with circular references instead of throwing errors","It's faster and more efficient","It preserves object methods while cloning"],code:"function cloneObject(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction betterCloneObject(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  const clone = Array.isArray(obj) ? [] : {};\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clone[key] = betterCloneObject(obj[key]);\n    }\n  }\n  \n  return clone;\n}",nextQuestionPath:"what-is-the-memory-impact-of-arrow-functions-compared-to-regular-function-expressions",correctAnswer:2,explanation:"The key advantage of betterCloneObject is handling circular references: 1) JSON.stringify/parse throws errors with circular references, while the recursive approach can be modified to handle them, 2) While not implemented in the current version, the recursive approach can be extended with a Map to track already-cloned objects and avoid infinite recursion, 3) The JSON approach also loses non-JSON data types like functions, undefined, and Dates, 4) From a pure memory perspective, the recursive approach gives more control over the cloning process, 5) The recursive approach can be optimized for specific use cases, such as shallow cloning certain properties, 6) It allows for custom handling of specific object types, 7) However, without proper handling of circular references, the current implementation would still cause stack overflow errors, 8) This comparison demonstrates the tradeoffs between different deep cloning approaches.",id:974,quizId:42},33)})]})))}},function(e){e.O(0,[41966,25675,82893,92888,49774,40179],function(){return e(e.s=8072)}),_N_E=e.O()}]);